<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiTe: A quick start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiTe
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A quick start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This short tutorial shows how to simulate a given Gibbs model of T-tessellation. The simulation algorithm is described the in paper "A completely random T-tessellation model and Gibbsian extensions". It is a Metropolis-Hastings-Green algorithm. Three main ingredients are involved in the simulation:</p>
<ul>
<li>A dynamic T-tessellation. That is a T-tessellation that can evolve with time.</li>
<li>A Gibbs model specified by an energy function. T-tessellation with low energy are more likely.</li>
<li>A simulation engine that make the dynamic T-tessellation evolve according to the specified model. The series of T-tessellations generated by the algorithm is a Markov chain of T-tessellations that converges in law to the target distribution.</li>
</ul>
<p>Below is the whole program. Comments about its different parts follow. </p>
<pre class="fragment">#include ttessel.h
int main(int argc,char** argv) {
  int seed = 5;               // seed for the random generator
  double width = 1;           // side length of the square domain to be tessellated
  double theta_segs = 3.15;   // first parameter value
  double theta_faces = 10000; // second parameter value
  TTessel tes; 
  tes.insert_window(Rectangle(Point2(0,0),Point2(width,width)));
  Energy mod;
  mod.add_features_segs(is_segment_internal);
  mod.add_theta_segs(theta_segs);
  mod.add_features_faces(face_area_2);
  mod.add_theta_faces(theta_faces);
  mod.set_ttessel(tes);
  std::cout &lt;&lt; "Current energy: " &lt;&lt; mod.get_value() &lt;&lt; std::endl;
  SMFChain sim = SMFChain(&amp;mod,0.33,0.33); 
  rnd = new CGAL::Random(seed);
  for(int i=0;i!=100;i++) {
    sim.step();
    std::cout &lt;&lt; "Current energy: " &lt;&lt; mod.get_value() &lt;&lt; std::endl;
  }
return 0;
}
</pre><h2>Create a dynamic T-tessellation object </h2>
<p>A dynamic T-tessellation is represented by a <a class="el" href="classTTessel.html" title="Dynamic T-tessellation. ">TTessel</a> object. </p>
<pre class="fragment">TTessel tes; 
</pre><p>Before it is really effective, one should define the domain to be tessellated. It must be a bounded convex polygon. Here it is a square window. </p>
<pre class="fragment">tes.insert_window(Rectangle(Point2(0,0),Point2(width,width)));
</pre><h2>Define the Gibbs model to be simulated </h2>
<p>A stochastic model of T-tessellation is defined through an energy function. For a given energy function <img class="formulaInl" alt="$E$" src="form_11.png"/>, the infinitesimal probability to observe a T-tessellation <img class="formulaInl" alt="$T$" src="form_12.png"/> is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(dT) \propto \exp\left(-E(T)\right). \]" src="form_13.png"/>
</p>
<p> Using <a class="el" href="classEnergy.html" title="Energy of a Gibbsian random T-tessellation. ">Energy</a> objects, one may define a large class of parametric models. As an example, consider the model where the energy function has the form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_\theta(T) = \stackrel{\circ}{n}_\mathrm{s}(T)\theta_1+a^2(T)\theta_2, \]" src="form_14.png"/>
</p>
<p> where <img class="formulaInl" alt="$\stackrel{\circ}{n}_\mathrm{s}(T)$" src="form_15.png"/> is the number of tessellation segments not lying along the domain boundary and <img class="formulaInl" alt="$a^2(T)$" src="form_16.png"/> is the sum of squared cell areas. Observe that the first term of the energy penalizes T-tessellations with too many segments (cells), while the second term penalizes T-tessellation with heterogeneous cell areas. The numerical values of the parameters are the following: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \theta_1 &amp; = &amp; 3.15,\\ \theta_2 &amp; = &amp; 10000. \end{eqnarray*}" src="form_17.png"/>
</p>
<p>Let us push the first energy term into the model. The number of internal segments can be written as </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\sum_{s\in S(T)} I\{s\mbox{ is internal}\}\right), \]" src="form_18.png"/>
</p>
<p> where <img class="formulaInl" alt="$S(T)$" src="form_19.png"/> is the set of segments of the tessellation <img class="formulaInl" alt="$T$" src="form_12.png"/>. The following piece of code push this term into the model. </p>
<pre class="fragment">Energy mod;
mod.add_features_segs(is_segment_internal);
mod.add_theta_segs(theta_segs);
</pre><p>The handling of the second term is similar. The sum <img class="formulaInl" alt="$a^2(T)$" src="form_16.png"/> of squared cell areas can be written as </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{c\in C(T)} a(c)^2, \]" src="form_20.png"/>
</p>
<p> where <img class="formulaInl" alt="$C(T)$" src="form_21.png"/> is the set of cells (i.e. faces) of the tessellation <img class="formulaInl" alt="$T$" src="form_12.png"/> and <img class="formulaInl" alt="$a(c)$" src="form_22.png"/> is the area of the cell <img class="formulaInl" alt="$c$" src="form_23.png"/>. </p>
<pre class="fragment">mod.add_features_faces(face_area_2);
mod.add_theta_faces(theta_faces);
</pre><p>Now attach the dynamic T-tessellation object to the model object and evaluate the model energy for the current T-tessellation (empty tessellation). </p>
<pre class="fragment">mod.set_ttessel(tes);
std::cout &lt;&lt; "Current energy: " &lt;&lt; mod.get_value() &lt;&lt; std::endl;
</pre><h2>Set up the simulator and run it </h2>
<p>The class <a class="el" href="classSMFChain.html" title="Markovian T-tessellation. ">SMFChain</a> implements a simulation engine. It is an algorithm of Metropolis-Hastings-Green type defining a Markov chain in the space of T-tessellations. Transitions of the Markov chain are either merges, splits of flips (SMF). When defining a <a class="el" href="classSMFChain.html" title="Markovian T-tessellation. ">SMFChain</a> object, one needs to specifiy 2 probabilities : probability of proposing a merge, probability of proposing a split (the third probability for flips is complementary). Very often, these probabilities are chosen uniform. </p>
<pre class="fragment">SMFChain sim = SMFChain(&amp;mod,0.33,0.33); 
</pre><p>We are now ready for running the simulator through its method <a class="el" href="classSMFChain.html#a6c34fac84f9e2917f80fd4f8fcb9e328" title="Proceed to update(s) of the SMF chain. ">SMFChain::step</a>. As a prerequisite, the random generator must be initialized. </p>
<pre class="fragment">rnd = new CGAL::Random(seed);
for(int i=0;i!=100;i++) {
  sim.step();
  std::cout &lt;&lt; "Current energy: " &lt;&lt; mod.get_value() &lt;&lt; std::endl;
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 15 2015 19:24:21 for LiTe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
